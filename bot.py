import os
import asyncio
import logging
import aiohttp
import pandas as pd
from datetime import datetime, timedelta
from aiogram import Bot, Dispatcher, types
from aiogram.filters import Command
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.dispatcher.middlewares.base import BaseMiddleware
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from bs4 import BeautifulSoup

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
API_TOKEN = os.getenv('API_TOKEN')
ADMIN_CHAT_ID = 579542680  # –í–∞—à chat_id
CHANNEL_ID = --1002881724171  # ID –≤–∞—à–µ–≥–æ –∫–∞–Ω–∞–ª–∞ –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–π
ALLOWED_USERS = [ADMIN_CHAT_ID]

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–æ—Ç–∞
bot = Bot(
    token=API_TOKEN,
    default=DefaultBotProperties(parse_mode=ParseMode.HTML)
)
dp = Dispatcher()
scheduler = AsyncIOScheduler()

# ===== Middleware –¥–ª—è –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞ =====
class AccessMiddleware(BaseMiddleware):
    async def __call__(self, handler, event, data):
        user_id = None
        
        if event.message:
            user_id = event.message.from_user.id
        elif event.callback_query:
            user_id = event.callback_query.from_user.id
        
        if not user_id or user_id not in ALLOWED_USERS:
            return False
        
        return await handler(event, data)

dp.update.outer_middleware(AccessMiddleware())

# ===== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò =====
async def fetch_crypto_news():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–æ–≤–æ—Å—Ç–µ–π –æ ETH –∏–∑ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤"""
    sources = {
        "CoinDesk": "https://www.coindesk.com/tag/ethereum/feed",
        "The Block": "https://www.theblock.co/rss/ethereum",
        "CoinTelegraph": "https://cointelegraph.com/rss/tag/ethereum"
    }
    
    news_items = []
    
    async with aiohttp.ClientSession() as session:
        for source, url in sources.items():
            try:
                async with session.get(url) as response:
                    if response.status == 200:
                        xml = await response.text()
                        soup = BeautifulSoup(xml, 'xml')
                        
                        for item in soup.find_all('item')[:5]:  # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 5 –Ω–æ–≤–æ—Å—Ç–µ–π
                            title = item.title.text
                            link = item.link.text
                            pub_date = item.pubDate.text if item.pubDate else ""
                            
                            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–∞–∂–Ω–æ—Å—Ç—å –Ω–æ–≤–æ—Å—Ç–∏ –ø–æ –∫–ª—é—á–µ–≤—ã–º —Å–ª–æ–≤–∞–º
                            importance = "‚ùóÔ∏è"
                            keywords = ["hack", "exploit", "vulnerability", "critical", "emergency", "vitalik"]
                            if any(kw in title.lower() for kw in keywords):
                                importance = "‚ùóÔ∏è‚ùóÔ∏è‚ùóÔ∏è"
                            
                            news_items.append({
                                "source": source,
                                "title": f"{importance} {title}",
                                "link": link,
                                "pub_date": pub_date
                            })
            except Exception as e:
                logging.error(f"Error fetching news from {source}: {e}")
    
    return news_items

async def get_eth_price():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã ETH"""
    url = "https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd"
    
    async with aiohttp.ClientSession() as session:
        try:
            async with session.get(url) as response:
                data = await response.json()
                return data["ethereum"]["usd"]
        except Exception as e:
            logging.error(f"Error fetching ETH price: {e}")
            return None

async def get_candles(timeframe="1d"):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å–≤–µ—á–µ–π"""
    interval_map = {
        "1h": "1h",
        "4h": "4h",
        "1d": "1d",
        "1w": "1w"
    }
    
    url = f"https://api.binance.com/api/v3/klines?symbol=ETHUSDT&interval={interval_map[timeframe]}&limit=2"
    
    async with aiohttp.ClientSession() as session:
        try:
            async with session.get(url) as response:
                data = await response.json()
                return data
        except Exception as e:
            logging.error(f"Error fetching candles: {e}")
            return None

def analyze_candle(candle):
    """–ê–Ω–∞–ª–∏–∑ —Å–≤–µ—á–∏ –∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–≥–Ω–æ–∑–∞"""
    open_price = float(candle[1])
    high = float(candle[2])
    low = float(candle[3])
    close = float(candle[4])
    
    # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–∏–ø–∞ —Å–≤–µ—á–∏
    candle_type = "üü¢" if close > open_price else "üî¥"
    
    # –ê–Ω–∞–ª–∏–∑ —Ä–∞–∑–º–µ—Ä–∞ —Å–≤–µ—á–∏
    size = abs(close - open_price)
    body_size = size / open_price * 100
    
    # –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–æ–≥–Ω–æ–∑–∞
    if candle_type == "üü¢":
        if body_size > 3:
            scenario = "–°–∏–ª—å–Ω—ã–π –±—ã—á–∏–π –∏–º–ø—É–ª—å—Å. –í–æ–∑–º–æ–∂–µ–Ω —Ä–æ—Å—Ç –∫ —Å–ª–µ–¥—É—é—â–µ–º—É —É—Ä–æ–≤–Ω—é —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏—è."
        else:
            scenario = "–ù–µ–±–æ–ª—å—à–æ–π —Ä–æ—Å—Ç. –¢—Ä–µ–±—É–µ—Ç—Å—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –¥–ª—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è."
    else:
        if body_size > 3:
            scenario = "–°–∏–ª—å–Ω–æ–µ –¥–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ–¥–∞–≤—Ü–æ–≤. –í–æ–∑–º–æ–∂–Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ü–∏—è –∫ —É—Ä–æ–≤–Ω—è–º –ø–æ–¥–¥–µ—Ä–∂–∫–∏."
        else:
            scenario = "–ù–µ–±–æ–ª—å—à–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è. –¢—Ä–µ–Ω–¥ –ø–æ–∫–∞ –Ω–µ –Ω–∞—Ä—É—à–µ–Ω."
    
    # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–ª—é—á–µ–≤—ã—Ö —É—Ä–æ–≤–Ω–µ–π
    support = round(low * 0.995, 2)
    resistance = round(high * 1.005, 2)
    
    return {
        "type": candle_type,
        "open": open_price,
        "high": high,
        "low": low,
        "close": close,
        "scenario": scenario,
        "support": support,
        "resistance": resistance
    }

def get_altseason_indicator():
    """–†–∞—Å—á–µ—Ç –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –∞–ª—å—Ç—Å–µ–∑–æ–Ω–∞ (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
    # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –∞–Ω–∞–ª–∏–∑ –¥–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏—è BTC/ETH
    # –ü–æ–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ª—É—á–∞–π–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
    import random
    value = random.randint(0, 100)
    
    if value < 30:
        return f"üî¥ {value} - –î–æ–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ BTC. –ê–ª—å—Ç—Å–µ–∑–æ–Ω –º–∞–ª–æ–≤–µ—Ä–æ—è—Ç–µ–Ω."
    elif value < 70:
        return f"üü° {value} - –ü–µ—Ä–µ—Ö–æ–¥–Ω–∞—è —Ñ–∞–∑–∞. –í–æ–∑–º–æ–∂–Ω—ã –¥–≤–∏–∂–µ–Ω–∏—è –∞–ª—å—Ç–æ–≤."
    else:
        return f"üü¢ {value} - –ê–ª—å—Ç—Å–µ–∑–æ–Ω! –†–æ—Å—Ç –∞–ª—å—Ç–∫–æ–∏–Ω–æ–≤ –≤–µ—Ä–æ—è—Ç–µ–Ω."

def format_whale_message(amount_usd):
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è –æ whale-—Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ —Å —ç–º–æ–¥–∑–∏"""
    if amount_usd > 100_000_000:
        return f"üö®üêã –ö–ò–¢–û–í–ê–Ø –¢–†–ê–ù–ó–ê–ö–¶–ò–Ø! ${amount_usd/1_000_000:.1f}M"
    elif amount_usd > 50_000_000:
        return f"üêã –ö—Ä—É–ø–Ω–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è ${amount_usd/1_000_000:.1f}M"
    elif amount_usd > 10_000_000:
        return f"üí∞ –ó–Ω–∞—á–∏—Ç–µ–ª—å–Ω–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è ${amount_usd/1_000_000:.1f}M"
    else:
        return f"‚ÜïÔ∏è –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è ${amount_usd/1_000_000:.1f}M"

# ===== –ó–ê–ü–õ–ê–ù–ò–†–û–í–ê–ù–ù–´–ï –ó–ê–î–ê–ß–ò =====
async def publish_eth_news():
    """–ü—É–±–ª–∏–∫–∞—Ü–∏—è –Ω–æ–≤–æ—Å—Ç–µ–π –æ ETH"""
    try:
        news = await fetch_crypto_news()
        for item in news:
            message = (
                f"{item['title']}\n\n"
                f"üì∞ –ò—Å—Ç–æ—á–Ω–∏–∫: {item['source']}\n"
                f"‚è∞ –î–∞—Ç–∞: {item['pub_date']}\n"
                f"<a href='{item['link']}'>–ß–∏—Ç–∞—Ç—å –ø–æ–ª–Ω–æ—Å—Ç—å—é</a>"
            )
            await bot.send_message(CHANNEL_ID, message, disable_web_page_preview=True)
            await asyncio.sleep(5)  # –ü–∞—É–∑–∞ –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
    except Exception as e:
        logging.error(f"Error publishing news: {e}")

async def send_candle_analysis(timeframe):
    """–ê–Ω–∞–ª–∏–∑ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ —Å–≤–µ—á–∞–º"""
    try:
        candles = await get_candles(timeframe)
        if not candles or len(candles) < 2:
            return
        
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∑–∞–∫—Ä—ã—Ç—É—é —Å–≤–µ—á—É
        candle_data = analyze_candle(candles[-2])
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        timeframe_emoji = {
            "1h": "‚è±",
            "4h": "üïì",
            "1d": "üìÖ",
            "1w": "üóì"
        }
        
        message = (
            f"{timeframe_emoji.get(timeframe, 'üìä')} <b>–ê–Ω–∞–ª–∏–∑ {timeframe.upper()} —Å–≤–µ—á–∏ ETH/USDT</b>\n\n"
            f"{candle_data['type']} <b>–ó–∞–∫—Ä—ã—Ç–∏–µ:</b> ${candle_data['close']:.2f}\n"
            f"‚ñ´Ô∏è High: ${candle_data['high']:.2f}\n"
            f"‚ñ´Ô∏è Low: ${candle_data['low']:.2f}\n"
            f"‚ñ´Ô∏è Open: ${candle_data['open']:.2f}\n\n"
            f"üìä <b>–ö–ª—é—á–µ–≤—ã–µ —É—Ä–æ–≤–Ω–∏:</b>\n"
            f"–ü–æ–¥–¥–µ—Ä–∂–∫–∞: ${candle_data['support']:.2f}\n"
            f"–°–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ: ${candle_data['resistance']:.2f}\n\n"
            f"üí° <b>–°—Ü–µ–Ω–∞—Ä–∏–π:</b>\n{candle_data['scenario']}"
        )
        
        await bot.send_message(CHANNEL_ID, message)
    except Exception as e:
        logging.error(f"Error sending candle analysis: {e}")

async def send_altseason_indicator():
    """–û—Ç–ø—Ä–∞–≤–∫–∞ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–∞ –∞–ª—å—Ç—Å–µ–∑–æ–Ω–∞"""
    try:
        indicator = get_altseason_indicator()
        message = (
            "üåê <b>–ò–ù–î–ò–ö–ê–¢–û–† –ê–õ–¨–¢–°–ï–ó–û–ù–ê</b>\n\n"
            f"{indicator}\n\n"
            "‚ÑπÔ∏è –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –Ω–∞—á–∞–ª–∞ –∞–ª—å—Ç—Å–µ–∑–æ–Ω–∞ "
            "(–ø–µ—Ä–∏–æ–¥–∞ —Ä–æ—Å—Ç–∞ –∞–ª—å—Ç–∫–æ–∏–Ω–æ–≤ –ø—Ä–æ—Ç–∏–≤ BTC)."
        )
        await bot.send_message(CHANNEL_ID, message)
    except Exception as e:
        logging.error(f"Error sending altseason indicator: {e}")

async def monitor_price_changes():
    """–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Ä–µ–∑–∫–∏—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π —Ü–µ–Ω—ã"""
    try:
        current_price = await get_eth_price()
        if not current_price:
            return
        
        # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Ü–µ–Ω–æ–π
        # –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ª—É—á–∞–π–Ω–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ
        import random
        change = random.uniform(-5, 5)
        
        if abs(change) > 3:
            direction = "üìà" if change > 0 else "üìâ"
            message = (
                f"{direction * 3} <b>–†–ï–ó–ö–û–ï –ò–ó–ú–ï–ù–ï–ù–ò–ï –¶–ï–ù–´ ETH!</b> {direction * 3}\n\n"
                f"‚ñ´Ô∏è –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: <b>${current_price:,.2f}</b>\n"
                f"‚ñ´Ô∏è –ò–∑–º–µ–Ω–µ–Ω–∏–µ: <b>{change:.2f}%</b> –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–π —á–∞—Å\n\n"
                f"‚ö†Ô∏è –í–æ–∑–º–æ–∂–Ω—ã –ø–æ–≤—ã—à–µ–Ω–Ω—ã–µ –∫–æ–ª–µ–±–∞–Ω–∏—è —Ä—ã–Ω–∫–∞"
            )
            await bot.send_message(CHANNEL_ID, message)
    except Exception as e:
        logging.error(f"Error monitoring price changes: {e}")

# ===== –ò–ú–ò–¢–ê–¶–ò–Ø –ü–ê–†–°–ò–ù–ì–ê –¢–ï–õ–ï–ì–†–ê–ú –ö–ê–ù–ê–õ–û–í =====
# –î–æ–±–∞–≤–ª—è–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∏–º–ø–æ—Ä—Ç—ã
import re
import logging
from telethon import TelegramClient, events

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è Telegram API (–¥–æ–±–∞–≤—å—Ç–µ –≤ —Ä–∞–∑–¥–µ–ª –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏)
TELEGRAM_API_ID = os.getenv('TELEGRAM_API_ID')
TELEGRAM_API_HASH = os.getenv('TELEGRAM_API_HASH')
LIQUIDATIONS_CHANNEL = 'BinanceLiquidations'

# ===== –†–ï–ê–õ–¨–ù–´–ô –ü–ê–†–°–ò–ù–ì –õ–ò–ö–í–ò–î–ê–¶–ò–ô =====
async def parse_real_liquidations():
    """–ü–∞—Ä—Å–∏–Ω–≥ —Ä–µ–∞–ª—å–Ω—ã—Ö –ª–∏–∫–≤–∏–¥–∞—Ü–∏–π —Å Telegram-–∫–∞–Ω–∞–ª–∞"""
    liquidations = []
    client = TelegramClient('binance_session', TELEGRAM_API_ID, TELEGRAM_API_HASH)
    
    try:
        await client.start()
        channel = await client.get_entity(LIQUIDATIONS_CHANNEL)
        
        # –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 10 —Å–æ–æ–±—â–µ–Ω–∏–π
        messages = await client.get_messages(channel, limit=10)
        
        for msg in messages:
            if data := parse_liquidation_message(msg.text):
                liquidations.append(data)
                
    except Exception as e:
        logging.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –ª–∏–∫–≤–∏–¥–∞—Ü–∏–π: {str(e)}")
    finally:
        await client.disconnect()
    
    return liquidations

def parse_liquidation_message(text: str) -> dict | None:
    """–†–∞–∑–±–æ—Ä —Å–æ–æ–±—â–µ–Ω–∏—è —Å –ª–∏–∫–≤–∏–¥–∞—Ü–∏–µ–π"""
    if not text or not text.startswith("Liquidated on"):
        return None
    
    try:
        # –ü—Ä–∏–º–µ—Ä —Å–æ–æ–±—â–µ–Ω–∏—è:
        # Liquidated on #ETH: 1.234M $ at $3500.00
        # Short | Cross
        lines = text.split('\n')
        if len(lines) < 2:
            return None
        
        # –ü–∞—Ä—Å–∏–Ω–≥ –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–∏
        match = re.search(r"#(\w+): ([\d\.]+[MK]?)\s*\$\s*at\s*\$\s*([\d\.,]+)", lines[0])
        if not match:
            return None
        
        symbol = match.group(1)  # ETH, BTC –∏ —Ç.–¥.
        amount_str = match.group(2).replace(',', '')
        price = float(match.group(3).replace(',', ''))
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Å—É–º–º—ã (1K = 1000, 1M = 1000000)
        multiplier = 1
        if 'M' in amount_str:
            multiplier = 1_000_000
            amount_str = amount_str.replace('M', '')
        elif 'K' in amount_str:
            multiplier = 1_000
            amount_str = amount_str.replace('K', '')
        
        amount = float(amount_str) * multiplier
        
        # –ü–∞—Ä—Å–∏–Ω–≥ –≤—Ç–æ—Ä–æ–π —Å—Ç—Ä–æ–∫–∏
        position_type = "Long" if "Long" in lines[1] else "Short"
        
        return {
            'symbol': symbol,
            'amount': amount,
            'price': price,
            'position': position_type
        }
    
    except (ValueError, IndexError) as e:
        logging.warning(f"–û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞ —Å–æ–æ–±—â–µ–Ω–∏—è: {str(e)}")
        return None

async def publish_real_liquidations():
    """–ü—É–±–ª–∏–∫–∞—Ü–∏—è —Ä–µ–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –æ –ª–∏–∫–≤–∏–¥–∞—Ü–∏—è—Ö"""
    try:
        # –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        liquidations = await parse_real_liquidations()
        
        if liquidations:
            # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ ETH –∏ –±–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –ª–∏–∫–≤–∏–¥–∞—Ü–∏—é
            eth_liquidations = [l for l in liquidations if l['symbol'] == 'ETH']
            if eth_liquidations:
                last = eth_liquidations[0]
                amount = last['amount']
                price = last['price']
                position = last['position']
                
                message = (
                    "üìâ <b>–†–ï–ê–õ–¨–ù–ê–Ø –õ–ò–ö–í–ò–î–ê–¶–ò–Ø ETH –ù–ê BINANCE!</b>\n\n"
                    f"‚ñ´Ô∏è –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: <b>{position}</b>\n"
                    f"‚ñ´Ô∏è –°—É–º–º–∞: <b>${amount/1_000_000:.2f}M</b>\n"
                    f"‚ñ´Ô∏è –¶–µ–Ω–∞: ${price:.2f}\n"
                    f"‚ñ´Ô∏è –í—Ä–µ–º—è: {datetime.utcnow().strftime('%H:%M UTC')}\n\n"
                    "#ETH #Liquidation #Binance"
                )
                await bot.send_message(CHANNEL_ID, message)
                return
        
        # –†–µ–∑–µ—Ä–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç –µ—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç
        logging.warning("–ù–µ –Ω–∞–π–¥–µ–Ω—ã —Å–≤–µ–∂–∏–µ –ª–∏–∫–≤–∏–¥–∞—Ü–∏–∏ ETH, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Ä–µ–∑–µ—Ä–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç")
        import random
        amount = random.uniform(1, 10) * 1_000_000
        price = await get_eth_price() or 3500
        position = random.choice(['LONG', 'SHORT'])
        
        message = (
            "üìâ <b>–õ–ò–ö–í–ò–î–ê–¶–ò–Ø ETH (—Ä–µ–∑–µ—Ä–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ)</b>\n\n"
            f"‚ñ´Ô∏è –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: <b>{position}</b>\n"
            f"‚ñ´Ô∏è –°—É–º–º–∞: <b>${amount/1_000_000:.2f}M</b>\n"
            f"‚ñ´Ô∏è –¶–µ–Ω–∞: ${price:.2f}\n"
            f"‚ñ´Ô∏è –í—Ä–µ–º—è: {datetime.utcnow().strftime('%H:%M UTC')}\n\n"
            "#ETH #Liquidation"
        )
        await bot.send_message(CHANNEL_ID, message)
        
    except Exception as e:
        logging.critical(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –ª–∏–∫–≤–∏–¥–∞—Ü–∏–π: {str(e)}")

async def simulate_whale_alert():
    """–ò–º–∏—Ç–∞—Ü–∏—è –ø–∞—Ä—Å–∏–Ω–≥–∞ Whale Alert"""
    try:
        # –í —Ä–µ–∞–ª—å–Ω–æ–π —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–µ—Å—å –±—É–¥–µ—Ç –ø–∞—Ä—Å–∏–Ω–≥ @whale_alert_io
        # –î–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ñ–µ–π–∫–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        import random
        eth_amount = random.uniform(10_000, 50_000)
        price = await get_eth_price()
        if not price:
            price = 3500
        amount_usd = eth_amount * price
        
        message = (
            f"{format_whale_message(amount_usd)}\n\n"
            f"‚ñ´Ô∏è –°—É–º–º–∞: <b>{eth_amount:,.0f} ETH</b> (${amount_usd/1_000_000:.2f}M)\n"
            f"‚ñ´Ô∏è –û—Ç: {random.choice(['Binance', 'Coinbase', 'Unknown wallet'])}\n"
            f"‚ñ´Ô∏è –ö: {random.choice(['Cold wallet', 'Exchange', 'DeFi contract'])}\n"
            f"‚ñ´Ô∏è –í—Ä–µ–º—è: {datetime.utcnow().strftime('%H:%M UTC')}\n\n"
            "#ETH #WhaleAlert"
        )
        await bot.send_message(CHANNEL_ID, message)
    except Exception as e:
        logging.error(f"Error simulating whale alerts: {e}")

# ===== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ü–õ–ê–ù–ò–†–û–í–©–ò–ö–ê =====
def setup_scheduler():
    # –ù–æ–≤–æ—Å—Ç–∏ –∫–∞–∂–¥—ã–µ 4 —á–∞—Å–∞
    scheduler.add_job(publish_eth_news, 'interval', hours=4)
    
    # –ê–Ω–∞–ª–∏–∑ —Å–≤–µ—á–µ–π
    scheduler.add_job(send_candle_analysis, 'cron', hour='*/1', args=["1h"])  # –ö–∞–∂–¥—ã–π —á–∞—Å
    scheduler.add_job(send_candle_analysis, 'cron', hour='*/4', args=["4h"])  # –ö–∞–∂–¥—ã–µ 4 —á–∞—Å–∞
    scheduler.add_job(send_candle_analysis, 'cron', hour=0, minute=5, args=["1d"])  # –ï–∂–µ–¥–Ω–µ–≤–Ω–æ –≤ 00:05 UTC
    scheduler.add_job(send_candle_analysis, 'cron', day_of_week='sun', hour=23, minute=55, args=["1w"])  # –í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ 23:55 UTC
    
    # –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∞–ª—å—Ç—Å–µ–∑–æ–Ω–∞ –µ–∂–µ–¥–Ω–µ–≤–Ω–æ –≤ 12:00 –ø–æ –õ–æ–Ω–¥–æ–Ω—É (11:00 UTC)
    scheduler.add_job(send_altseason_indicator, 'cron', hour=11, minute=0)
    
    # –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ —Ü–µ–Ω—ã –∫–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç
    scheduler.add_job(monitor_price_changes, 'interval', minutes=30)
    
    # –ò–º–∏—Ç–∞—Ü–∏—è –ª–∏–∫–≤–∏–¥–∞—Ü–∏–π –∏ whale alert
    scheduler.add_job(simulate_binance_liquidations, 'interval', minutes=15)
    scheduler.add_job(simulate_whale_alert, 'interval', minutes=20)
    
    scheduler.start()

# ===== –û–°–ù–û–í–ù–´–ï –ö–û–ú–ê–ù–î–´ =====
@dp.message(Command("start"))
async def cmd_start(message: types.Message):
    await message.answer(
        "üöÄ <b>Ethereum Tracker Bot –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!</b>\n\n"
        "–ë–æ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—É–±–ª–∏–∫—É–µ—Ç:\n"
        "‚úÖ –ù–æ–≤–æ—Å—Ç–∏ –æ–± ETH\n"
        "üìà –ê–Ω–∞–ª–∏–∑ —Ü–µ–Ω–æ–≤—ã—Ö –¥–≤–∏–∂–µ–Ω–∏–π\n"
        "üìâ –î–∞–Ω–Ω—ã–µ –æ –ª–∏–∫–≤–∏–¥–∞—Ü–∏—è—Ö\n"
        "üêã –ö—Ä—É–ø–Ω—ã–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (Whale Alert)\n"
        "üåê –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∞–ª—å—Ç—Å–µ–∑–æ–Ω–∞\n\n"
        "–í—Å–µ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏ –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –≤ —É–∫–∞–∑–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª."
    )

# ===== –ó–ê–ü–£–°–ö –ë–û–¢–ê =====
async def on_startup():
    logging.info("Starting scheduler...")
    setup_scheduler()
    await bot.send_message(ADMIN_CHAT_ID, "üü¢ Ethereum Tracker Bot –∑–∞–ø—É—â–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç!")

async def on_shutdown():
    logging.info("Stopping scheduler...")
    scheduler.shutdown()
    await bot.send_message(ADMIN_CHAT_ID, "üî¥ Ethereum Tracker Bot –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!")
    await bot.session.close()

async def main():
    logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(name)s - %(message)s")
    
    await on_startup()
    await dp.start_polling(bot)
    await on_shutdown()

if __name__ == "__main__":
    asyncio.run(main())
